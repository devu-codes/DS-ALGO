 Hash Functions Work -- 
 Should always map a large key to same small key
 should generate vlaues from 0 to m-1
 should be fast, O(1) for integer O(len) for string of length 'len'
 should uniformly distribute lasrge keys into hash Table.

 h(large_keys) = large_key % m

 For strings, weighted sum
 str[] = "abcd"

 str[o]*x + str[1] * x + ....

 Universal Hashing

Birthday Paradox - 
if there are 23 ppl , then 50% chances that 2 ppl have same birthday
if 70 then 99.9% .

 Collsion Handling 
 If we dont know keys, then we use
 -- Chaining 
 -- Open Addressing 
 	-- Linear Probing
 	-- Quadratic Probing 
 	-- Double Hashing 


Chaining 

hash(Key) = Key%7

Keys = [50, 21, 58, 17, 15, 49, 56, 22, 23, 25]

		0 --> 21 --> 49 --> 56
		1 --> 50 --> 15 --> 22 
		2 --> 58 --> 23
		3 --> 17 
		4 --> 25 
		5
		6

Performance 
	m = No of slots in HashTable 
	n = No of keys to be inserted

	load factor =  n/m
	Chain length = Load factor 
	Expected time to search/insert/delete = O(1+alpha)


DS for storing chains
	-- Linked list search - delete - insert -- O(len)
	-- Dynamic sized Arrays (same as arrays)
	-- Self Balanced BST(AVL, RedBLack Tree)--search,insert,delete--Ologl)  


Chaining 									Open Addressing 
							|
1. Hash Table never fills 	| Table may become full and ringing 	         					| becomesmandatory.
							|
2.less sensitive to hash fn.|Extra care req for clusturing.
							|
3.cache performance.		|Cache friendly.
							|
4.Extra space for links.	|Extra space might be needed to achieve same    
							|performance as chaining.
							|
							